/***********************************************************************
Name : Hyunjoo Han
Email : hhan39@myseneca.ca
ID : 132749227
Date of completion : 10/09/2023
***********************************************************************/
In this workshop, I've learned that I can create overloaded constructors in addition to the default constructor, providing a convenient method to configure constructors when dealing with multiple member values. I found this very useful, especially when you want some members to have default values and others to have specific values.
For instance, in Part 1 Lab, I had to design two constructors: one for default values and another to set different values for members. The 'CarInventory(const char* type, const char* brand, const char* model, int year, int code, double price);' constructor requires five arguments to accommodate different types. However, 'year,' 'code,' and 'price' have default parameter values. This means that even with just two arguments (for 'type' and 'brand'), it will assign them to the correct values while retaining the default parameter values. Creating overloaded constructors and setting default parameter values provides me with the flexibility to customize my constructors according to my needs.
In Part 2 DIY, I needed to create three constructors: one for default values, one to set a value for 'm_frame,' and another to set values for both 'm_frame' and 'm_text.' If I want to set a value only for 'm_frame,' I can call 'Label(const char* frameArg);' or, if I want to set values for both variables, I can use 'Label(const char* frameArg, const char* content);.' This way, I have the option to set only one of them to the default value while assigning a non-default value to the other. I believe this enhances communication options.
Furthermore, I've found destructors to be very convenient. While working on previous workshops, I encountered a few memory leaks and had to spend some time to figure it out. By creating a destructor, I worry less about memory leaks, as it deletes the memory when it goes out of scope. I believe this is a highly helpful way to release member pointers. 
I am convinced that I need to deepen my understanding of the concepts mentioned above to gain confidence in initializing class members.

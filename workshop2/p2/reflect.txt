/***********************************************************************
Name : Hyunjoo Han
Email : hhan39@myseneca.ca
ID : 132749227
Date of completion : 9/26/2023
***********************************************************************/

In this workshop, the newest concept for me was Dynamic Memory. Dynamic memory allocation allows me to request memory space from the system at runtime, unlike static memory, where I must rely on the compiler to allocate memory for variables. With static memory, I often need to allocate extra space to accommodate variables of varying sizes.
Once I have allocated dynamic memory, I have to also release it, making it available for other purposes. To release dynamic memory, I use the 'Deallocation' process, which involves the 'delete' command. I understand that this is not only important for making memory reusable but also for preventing memory leaks. One of the advantages of using dynamic memory is its ability to enable the creation of data structures with different sizes.
In Part 1, I had to create two dynamic memory allocations: one for 'employees' and one for 'name.' To determine the size of memory needed for 'employees,' I called the 'noOfRecords' function and stored its return value in a variable, which I then used to allocate dynamic memory. For 'name,' I used the 'strlen' function to determine the length of the name.
In Part 2, I created two dynamic memory allocations for 'recordPopulation' and 'matchPopulation.' 'recordPopulation' stores records from a file, and 'matchPopulation' stores matching values. Again, I called the 'noOfRecords' function from Part 1 to determine the size of memory needed for 'recordPopulation.' For 'matchPopulation,' I used 'startsWith' to count the matching records.
When it comes to deallocation, one important aspect I needed to pay attention to was deallocating 'name.' Since 'name' is within a struct, I had to include it in a for-loop to ensure that every member is released.
The next new concept was overloading functions. This allows me to define multiple functions with the same name in the same scope, but I need to ensure that they have different parameter lists. The compiler will then distinguish between these functions based on parameter types or the number of parameters.
I have created three sets of overloaded functions for each part. Each set has a different parameter type and a different number of parameters, which makes each function within them distinguishable from the others
Finally, I needed to understand the concept of references because it was confusing to me. Initially, it appeared to be the address of a variable, which led me to clarify that it is not a pointer. Now, I understand that it works as an alias or a means to access a variable using a different name. It is not precisely an address for the variable. What makes it efficient is that it doesn't require extra memory to store the address of the variable, as is the case with pointers. I've come to understand that using a reference is a more efficient way to access and manipulate the value of a variable. Personally, I find it makes the code cleaner and easier to read since it eliminates the need for dereferencing.
/***********************************************************************
Name : Hyunjoo Han
Email : hhan39@myseneca.ca
ID : 132749227
Date of completion : 11/02/2023
***********************************************************************/

During the workshop, I was tasked with defining multiple constructors for the class, each serving a specific purpose. I needed to create constructors with different parameter configurations, including one with parameters, one without parameters, and a copy constructor. Here is an example of what I implemented

>> Constructor with parameters and default value
*** HealthCard(const char* name = nullptr, long long number = 0, const char vCode[] = {}, const char sNumber[] = {});
To make the code more flexible for these two constructors, I set default parameter values to represent the empty state. This allowed one constructor to handle different scenarios effectively.

>> Copy constructor to create a new instance fro an existing one
*** HealthCard(const HealthCard& hc);
I also had to define and implement a copy constructor for the class. The copy constructor's form typically follows the pattern above.
For the implementation, I ensured proper handling of dynamic memory by performing a deep copy. Instead of copying the address (pointer) of the variable, I copied the actual value. To achieve this, I used the copy assignment operator, as it was a reusable solution.

The new concept of this workshop was the "rule of three," which required me to define and implement three essential functions: the copy constructor, the copy assignment operator, and the destructor to manage resources properly. Here are the three functions I needed to work on:

>>Copy constructor above

>>Copy Assignment Operator
*** HealthCard& operator=(const HealthCard& hc);
To make this process more efficient, I leveraged the existing 'set' function, which was already implemented as a private method.

>>Destructor
*** ~HealthCard();

For Milestone1, I had to do a similar(same) task for the 'Status' module. However, for the 'Status' class, I utilized the 'alocpy' function from the 'Utils' module to perform a deep copy of variables with dynamic memory.

Furthermore, I had to read formatted data by using isteam and write formatted data using ostream.

>>Reading formatted data by using an istream
*** std::istream& HealthCard::read(std::istream& istr);
In this function, I employed local temporary variables to store the values obtained from the input stream. I read characters into these variables until they reached the designated delimiter (comma or dash). Following this, I utilized the extractChar function to remove the delimiter characters (comma and dash). Once all data was successfully read, I assigned the values to the corresponding local variables by invoking the 'set' function. 
*** std::istream& Data::read(std::istream& istr);
In the Milestone1, the Date module also includes a read function utilizing istream:

>>Writing formatted data by using an ostream
*** std::ostream& print(std::ostream& ostr, bool toFile = true)const;
This function first verifies the validity of the object. Depending on the value of the 'toFile' parameter, it formats the variables and prints them accordingly. To achieve this, I used various output formatting functions such as width, set, and fill. The printIDInfo member function was very helpful in this process.
***std::ostream& write(std::ostream& ostr);
Again for the Milestoe1, Date module has writing function using stream

For both the read and write functions, returning an istream or ostream object allows for the chaining of input and output operations, enabling a more streamlined and efficient data handling process.

Finally, I had to overload the extraction and insertion operators for I/O, using iostream. The code overloads the << and >> operators to enable easy input and output operations with HealthCard objects. This allows user to read and write HealthCard objects using the input and output streams
*** std::ostream& operator<<(std::ostream& ostr, const HealthCard& hc);
*** std::istream& operator>>(std::istream& istr, HealthCard& hc);
These are for workshop 6
*** std::ostream& operator<<(std::ostream& ostr, const Date& date);
*** std::istream& operator>>(std::istream& is, Date& date);
And These are from 'Date' module of Milestone1
*** std::ostream& operator <<(std::ostream& ostr, const Status& status);
This is from 'Status' module of Milestone1
